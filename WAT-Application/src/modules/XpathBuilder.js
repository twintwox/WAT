/**
 * XpathBuilder provides methods to get XPaths of elements and get elements from Xpaths.
 * It can receive an "ignoreClass", to avoid counting those elements that contains the class into the generated xpaths.
 * **/
WAT.module('XpathBuilder',['JQuery','Logger'],function($,Logger){

	var $logger = new Logger('XpathBuilder');

	var XpathBuilder = function(ignore){
		// An ignoredClass param could be send to avoid considering those elements that match the class
		if(typeof ignore === 'string')
			this.ignoreClass = ignore;
		if(typeof  ignore === 'function')
			this.ignoreFn = ignore;
	};
	XpathBuilder.prototype.ignoreElement = function(element){
		if(this.ignoreFn) return this.ignoreFn(element);
		if(this.ignoreClass == null) return false;
		return $(element).hasClass(this.ignoreClass);
	};

	/**
	 * Get xpath of an element
	 * **/
	XpathBuilder.prototype.getPath = function(element) {
	    var paths = [];
	    // Use nodeName (instead of localName) so namespace prefix is included (if any).
	    for (;element && element.nodeType == 1; element = element.parentNode){
	        var index = 0;
	        for (var sibling = element.previousSibling; sibling; sibling = sibling.previousSibling){
	            // Ignore document type declaration.
	            if (sibling.nodeType == Node.DOCUMENT_TYPE_NODE)
	                continue;


	            if (sibling.nodeName == element.nodeName && !this.ignoreElement(sibling))
	                ++index;
	        }
	        var tagName = element.nodeName.toLowerCase();
	        var pathIndex = (index ? "[" + (index+1) + "]" : "");
	        paths.splice(0, 0, tagName + pathIndex);
	    }
	    return paths.length ? "/" + paths.join("/") : null;
	};

	/**
	 * Get element that match the path generated by the function getPath
	 * **/
	XpathBuilder.prototype.getElement = function(path) {
		var self = this;
		var findElement = function(context,path){
			var path = path.substring(1); // Remove first '/'
			if(!path) return null;
			var next = path.indexOf('/');
			var prefix = (next >= 0)? path.substring(0,next) : path;
			// Find tag position
			var pos = prefix.match(/\[\d+\]/g);
			pos = (pos && pos.length>0? parseInt(pos[0].match(/\d+/g)[0]) : 1) - 1;
			// Clean the tag position
			prefix = prefix.replace(/\[\d+\]/g,'');
			var elem;
			if(prefix === 'html') elem = context;
			else elem = $(context).children().filter(function(){
				return !self.ignoreElement(this);
			}).filter(prefix+":eq("+pos+")")[0];
			if(next==-1) return elem;
			return findElement(elem,path.substring(next));
		};
		return findElement(document.documentElement,path.toLowerCase());
		// /html/body/test/div[2]/span
		//if(!path) return null;
		//var evaluator = new XPathEvaluator();
	    //var result = evaluator.evaluate(path, document.documentElement, null,XPathResult.FIRST_ORDERED_NODE_TYPE, null);
	    //return  result.singleNodeValue;
	};

	/**
	 * Get all elements that has similar xpaths to the path generated by the function getPath
	 * (replacing the numbers in the xpath for any one)
	 * eg. body/div[1]/span => body/div/span
	 * **/
	XpathBuilder.prototype.getElements = function(path) {
		if(!path) return [];
		var newPath = path.replace(/\[\d+\]/g,'');
		return $(document).xpath(newPath);
	};


	/**
	 * Get a generic xpath from an element.
	 * Replacing all the numbers for nothing.
	 * eg. body/div[1]/span => body/div/span
	 * **/
	XpathBuilder.prototype.getWildcardPath = function(element) {
		if(!element) return;
		var path = this.getPath(element);
		if(!path){
			$logger.warn('GetWildcardPath fail to get path for',element);
			return;
		}
		return path.replace(/\[\d+\]/g,'');
	};

	/**
	 * Get all the elements that match a wilcard path (generated by the function getWildcardPath).
	 * **/
	XpathBuilder.prototype.fromWildcardPath = function(wildCardPath) {
		return $(document).xpath(wildCardPath);
	};


	return XpathBuilder;
});


